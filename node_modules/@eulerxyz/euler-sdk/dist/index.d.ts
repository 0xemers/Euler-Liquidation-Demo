import { ethers, ContractInterface } from "ethers";
import { ERC20Contract } from "./ERC20";
import * as utils from "./utils";
import { BatchItem, BatchResponse, TokenWithPermit, EulerAddresses, NetworkConfig, SignerOrProvider, Contracts } from "./types";
import { PTokenContract, ETokenContract, DTokenContract } from "./eulerTypes";
declare class Euler {
    readonly chainId: number;
    readonly contracts: Contracts;
    readonly abis: {
        [contractName: string]: ContractInterface;
    };
    readonly addresses: EulerAddresses;
    readonly eulTokenConfig: TokenWithPermit;
    readonly referenceAsset: string;
    private _tokenCache;
    private _underlyingToTokenCache;
    private _signerOrProvider?;
    constructor(signerOrProvider?: SignerOrProvider, chainId?: number, networkConfig?: NetworkConfig);
    connect(signerOrProvider: SignerOrProvider): this;
    getSigner(): ethers.Signer | null;
    getProvider(): ethers.providers.Provider | null;
    addContract(name: string, abi?: ContractInterface, address?: string): void;
    erc20(address: string): ERC20Contract;
    eToken(address: string): ETokenContract;
    dToken(address: string): DTokenContract;
    pToken(address: string): PTokenContract;
    eTokenOf(underlyingAddress: string): Promise<ETokenContract>;
    dTokenOf(underlyingAddress: string): Promise<DTokenContract>;
    pTokenOf(underlyingAddress: string): Promise<PTokenContract>;
    buildBatch(items: BatchItem[]): {
        allowError: boolean;
        proxyAddr: string;
        data: string;
    }[];
    simulateBatch(deferredLiquidity: string[], items: BatchItem[]): Promise<{
        simulation: any[] | undefined;
        gas: ethers.BigNumber | undefined;
        error: {
            isLiquidityCheck: boolean;
            value: any;
        } | undefined;
    }>;
    decodeBatch(items: BatchItem[], resp: BatchResponse[]): any[];
    signPermit(token: TokenWithPermit, { spender, value, allowed, deadline, }: {
        spender?: string | undefined;
        value?: ethers.BigNumber | undefined;
        allowed?: boolean | undefined;
        deadline?: number | undefined;
    }, signer?: ethers.Signer | null): Promise<{
        signature: {
            r: string;
            s: string;
            _vs: string;
            recoveryParam: number;
            v: number;
            yParityAndS: string;
            compact: string;
            raw: any;
        };
        nonce: any;
    }>;
    signPermitBatchItem(token: TokenWithPermit, { value, allowed, deadline, }: {
        value?: ethers.BigNumber | undefined;
        allowed?: boolean | undefined;
        deadline?: number | undefined;
    }, allowError?: boolean, signer?: ethers.Signer | null): Promise<{
        allowError: boolean;
        contract: string;
        method: string;
        args: any[];
    }>;
    private _getToken;
    private _getTokenOf;
    private _batchItemToContract;
    private _loadEulerContracts;
}
export { Euler, utils };
//# sourceMappingURL=index.d.ts.map