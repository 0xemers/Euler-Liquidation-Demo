import{ethers as e,utils as r,BigNumber as t,Contract as n}from"ethers";import s from"tiny-invariant";import i from"@eulerxyz/euler-interfaces/addresses/addresses-mainnet.json";import o from"@eulerxyz/euler-interfaces/addresses/addresses-ropsten.json";import a from"@eulerxyz/euler-interfaces/addresses/addresses-goerli.json";import{abi as d}from"@eulerxyz/euler-interfaces/abis/Eul.json";import{abi as c}from"@eulerxyz/euler-interfaces/abis/Euler.json";import{abi as u}from"@eulerxyz/euler-interfaces/abis/PToken.json";import{abi as l}from"@eulerxyz/euler-interfaces/abis/modules/EToken.json";import{abi as h}from"@eulerxyz/euler-interfaces/abis/modules/DToken.json";import{abi as f}from"@eulerxyz/euler-interfaces/abis/modules/Exec.json";import{abi as g}from"@eulerxyz/euler-interfaces/abis/modules/Liquidation.json";import{abi as m}from"@eulerxyz/euler-interfaces/abis/modules/Markets.json";import{abi as p}from"@eulerxyz/euler-interfaces/abis/modules/Swap.json";import{abi as v}from"@eulerxyz/euler-interfaces/abis/mining/EulStakes.json";import{abi as w}from"@eulerxyz/euler-interfaces/abis/mining/EulDistributor.json";import{abi as k}from"@eulerxyz/euler-interfaces/abis/views/EulerGeneralView.json";function y(){return y=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},y.apply(this,arguments)}function T(e,r){if(null==e)return{};var t,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)r.indexOf(t=i[n])>=0||(s[t]=e[t]);return s}const b=["event Approval(address indexed owner, address indexed spender, uint value)","event Transfer(address indexed from, address indexed to, uint value)","function name() external view returns (string memory)","function symbol() external view returns (string memory)","function decimals() external view returns (uint8)","function totalSupply() external view returns (uint)","function balanceOf(address owner) external view returns (uint)","function allowance(address owner, address spender) external view returns (uint)","function approve(address spender, uint value) external returns (bool)","function transfer(address to, uint value) external returns (bool)","function transferFrom(address from, address to, uint value) external returns (bool)"],_=["function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)","function nonces(address owner) view returns (uint)","function _nonces(address owner) view returns (uint)"],x=["function permit(address owner, address spender, uint value, uint deadline, bytes signature)","function nonces(address owner) view returns (uint)"],P=["function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)","function nonces(address owner) view returns (uint)"],E={Permit:[{name:"owner",type:"address"},{name:"spender",type:"address"},{name:"value",type:"uint256"},{name:"nonce",type:"uint256"},{name:"deadline",type:"uint256"}]},C={Permit:[{name:"holder",type:"address"},{name:"spender",type:"address"},{name:"nonce",type:"uint256"},{name:"expiry",type:"uint256"},{name:"allowed",type:"bool"}]},O=e=>e.charAt(0).toLowerCase()+e.substring(1),S=r=>{s(e.utils.isAddress(r),"Invalid address")},D=e=>Math.floor((Date.now()+1e3*e)/1e3),A=e=>{if("invalid codepoint at offset 2; missing continuation byte"===e.reason)try{let t=r.defaultAbiCoder.decode(["string"],e.value.slice(4))[0];e.reason=t,t=`execution reverted: ${t}`,e.message=t,e.msg=t,e.code=t}catch(e){}return e};var I,j={__proto__:null,getSubAccountId:function(e,r){return t.from(e).xor(r).toNumber()},isRealSubAccount:function(e,r){return t.from(e).xor(r).lt(256)},getSubAccount:function(e,n){if(parseInt(n)!==n||n>256)throw`invalid subAccountId: ${n}`;return r.hexZeroPad(t.from(e).xor(n).toHexString(),20)}},z={__proto__:null,eul:d,euler:c,pToken:u,eToken:l,dToken:h,exec:f,liquidation:g,markets:m,swap:p,eulStakes:v,eulDistributor:w,eulerGeneralView:k};!function(e){e.ERC20="erc20",e.EToken="eToken",e.DToken="dToken",e.PToken="pToken"}(I||(I={}));const B=["eul"],R=["eul"],$=["eul"],M=["e/collateral-violation","e/borrow-isolation-violation"];class q{constructor(e,r=1,t){if(this.chainId=void 0,this.contracts=void 0,this.abis=void 0,this.addresses=void 0,this.eulTokenConfig=void 0,this.referenceAsset=void 0,this._tokenCache=void 0,this._underlyingToTokenCache=void 0,this._signerOrProvider=void 0,this.chainId=r,this._tokenCache={[I.EToken]:{},[I.DToken]:{},[I.PToken]:{},[I.ERC20]:{}},this._underlyingToTokenCache={},this._signerOrProvider=e,1===this.chainId){const{eul:e}=i,r=T(i,B);this.eulTokenConfig=e,this.addresses=r,this.referenceAsset="0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"}else if(3===this.chainId){const{eul:e}=o,r=T(o,R);this.eulTokenConfig=e,this.addresses=r,this.referenceAsset="0xc778417e063141139fce010982780140aa0cd5ab"}else if(420===this.chainId){const{eul:e}=a,r=T(a,$);this.eulTokenConfig=e,this.addresses=r,this.referenceAsset="0xa3401DFdBd584E918f59fD1C3a558467E373DacC"}else{if(!t)throw new Error("Unknown configuration");s(t.addresses,`Missing addresses for chainId ${this.chainId}`),s(t.referenceAsset,`Missing reference asset for chainId ${this.chainId}`),this.addresses=t.addresses,this.referenceAsset=t.referenceAsset,this.eulTokenConfig=t.eul}this.abis=z,this.contracts=this._loadEulerContracts()}connect(e){return this._signerOrProvider=e,Object.entries(this.contracts).forEach(([r,t])=>{this.contracts[r]=t.connect(e)}),this}getSigner(){if(e.Signer.isSigner(this._signerOrProvider))return this._signerOrProvider;if(e.providers.BaseProvider.isProvider(this._signerOrProvider))try{return this._signerOrProvider.getSigner()}catch(e){}return null}getProvider(){return e.providers.BaseProvider.isProvider(this._signerOrProvider)?this._signerOrProvider:e.Signer.isSigner(this._signerOrProvider)&&this._signerOrProvider.provider?this._signerOrProvider.provider:null}addContract(r,t,n){s(r,"Contract name is required"),r=O(r),t=t||this.abis[r],s(Array.isArray(t),"Missing or invalid abi"),S(n=n||this.addresses[r]),this.contracts[r]=new e.Contract(n,t,"string"==typeof this._signerOrProvider?void 0:this._signerOrProvider),this.abis[r]=t,this.addresses[r]=n}erc20(e){return S(e),this._getToken(e,I.ERC20)}eToken(e){return S(e),this._getToken(e,I.EToken)}dToken(e){return S(e),this._getToken(e,I.DToken)}pToken(e){return S(e),this._getToken(e,I.PToken)}eTokenOf(e){return S(e),this._getTokenOf(e,I.EToken)}dTokenOf(e){return S(e),this._getTokenOf(e,I.DToken)}pTokenOf(e){return S(e),this._getTokenOf(e,I.PToken)}buildBatch(e){return e.map(e=>{let r=y({},e);if(r.staticCall){const e=this._batchItemToContract(r),t=e.interface.encodeFunctionData(r.method,r.args);r={allowError:r.allowError,contract:"exec",method:"doStaticCall",args:[e.address,t]}}const t=this._batchItemToContract(r);return{allowError:Boolean(r.allowError),proxyAddr:t.address,data:t.interface.encodeFunctionData(r.method,r.args)}})}async simulateBatch(e,r){var t=this;s(Array.isArray(r),"Expecting an array of batch items");const[n,{gas:i,error:o}]=await Promise.all([async function(){try{await t.contracts.exec.callStatic.batchDispatchSimulate(t.buildBatch(r),e)}catch(e){if("BatchDispatchSimulation"!==e.errorName)throw e;return t.decodeBatch(r,e.errorArgs.simulation)}}(),async function(){const n=r.filter(e=>!e.staticCall);try{return{gas:await t.contracts.exec.estimateGas.batchDispatch(t.buildBatch(n||r),e)}}catch(e){if(e.reason)for(const r of M)if(e.reason.includes(r))return{error:{isLiquidityCheck:!0,value:e}};return{error:{isLiquidityCheck:!1,value:e}}}}()]);return{simulation:n,gas:i,error:o}}decodeBatch(e,r){const t=[];for(let n=0;n<r.length;n++){const s=e[n];let i;try{i={success:!0,response:this._batchItemToContract(s).interface.decodeFunctionResult(s.method,r[n].result)}}catch(e){i={success:!1,response:A(e)}}t.push(i)}return t}signPermit(r,{spender:t=this.contracts.euler.address,value:n=e.constants.MaxUint256,allowed:i=!0,deadline:o=D(3600)},a=this.getSigner()){s(e.Signer.isSigner(this._signerOrProvider),"Signer in not provided"),s(r&&r.extensions&&r.extensions.permit,"Invalid token or missing permit config");const{type:d,variant:c,domain:u}=r.extensions.permit;return(async(r,{type:t,variant:n,domain:s},{spender:i,value:o,allowed:a,deadline:d},c)=>{if(!e.Signer.isSigner(c))throw new Error("Invalid signer");const u=c._signTypedData?c._signTypedData.bind(c):c.signTypedData.bind(c),l=await c.getAddress();if("EIP2612"===t){const t=new e.Contract(r,"PACKED"===n?x:_,c);let a;a="UNDERSCORE_NONCES"===n?await t._nonces(l):await t.nonces(l);const h=await u(s,E,{owner:l,spender:i,value:o,nonce:a,deadline:d});return{signature:y({raw:h},e.utils.splitSignature(h)),nonce:a}}if("ALLOWED"===t){const t=new e.Contract(r,P,c),n=await t.nonces(l),o=await u(s,C,{holder:l,spender:i,nonce:n,expiry:d,allowed:a});return{signature:y({raw:o},e.utils.splitSignature(o)),nonce:n}}throw new Error(`Unknown permit type: ${t}`)})(r.address,{type:d,variant:c,domain:u},{spender:t,value:n,allowed:i,deadline:o},a)}async signPermitBatchItem(r,{value:t=e.constants.MaxUint256,allowed:n=!0,deadline:s=D(3600)},i=!1,o=this.getSigner()){const{nonce:a,signature:d}=await this.signPermit(r,{spender:this.contracts.euler.address,value:t,allowed:n,deadline:s},o),{type:c,variant:u}=r.extensions.permit;let l;return l="EIP2612"===c?"PACKED"===u?{allowError:i,contract:"exec",method:"usePermitPacked",args:[r.address,t,s,d.raw]}:{allowError:i,contract:"exec",method:"usePermit",args:[r.address,t,s,d.v,d.r,d.s]}:{allowError:i,contract:"exec",method:"usePermitAllowed",args:[r.address,a,s,n,d.v,d.r,d.s]},l}_getToken(r,t){return this._tokenCache[t][r]||(this._tokenCache[t][r]=new e.Contract(r,t===I.ERC20?b:this.abis[t],"string"==typeof this._signerOrProvider?void 0:this._signerOrProvider)),this._signerOrProvider?this._tokenCache[t][r].connect(this._signerOrProvider):this._tokenCache[t][r]}async _getTokenOf(r,t){if(this._underlyingToTokenCache[r]||(this._underlyingToTokenCache[r]={}),!this._underlyingToTokenCache[r][t]){let n;if(t===I.EToken)n=await this.contracts.markets.underlyingToEToken(r);else if(t===I.DToken)n=await this.contracts.markets.underlyingToDToken(r);else{if(t!==I.PToken)throw new Error(`Unsupported token type: ${t}`);n=await this.contracts.markets.underlyingToPToken(r)}if(n===e.constants.AddressZero)throw new Error(`No ${t} found for underlying ${r}`);this._underlyingToTokenCache[r][t]=n}return this[t](this._underlyingToTokenCache[r][t])}_batchItemToContract(r){if(r.contract instanceof e.Contract)return r.contract;if(this.contracts[r.contract])return this.contracts[r.contract];if(r.address){if(r.contract===I.EToken)return this.eToken(r.address);if(r.contract===I.DToken)return this.dToken(r.address);if(r.contract===I.PToken)return this.pToken(r.address);if(r.contract===I.ERC20)return this.erc20(r.address)}throw new Error(`Unknown contract ${r.contract}`)}_loadEulerContracts(){const e=e=>new n(this.addresses[O(e)],this.abis[O(e)],"string"==typeof this._signerOrProvider?void 0:this._signerOrProvider);return{euler:e("Euler"),exec:e("Exec"),liquidation:e("Liquidation"),markets:e("Markets"),swap:e("Swap"),eulStakes:e("EulStakes"),eulDistributor:e("EulDistributor"),eulerGeneralView:e("EulerGeneralView"),eul:new n(this.eulTokenConfig.address,this.abis.eul,"string"==typeof this._signerOrProvider?void 0:this._signerOrProvider)}}}export{q as Euler,j as utils};
//# sourceMappingURL=index.modern.mjs.map
