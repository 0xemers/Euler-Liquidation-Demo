{"version":3,"file":"index.modern.mjs","sources":["../src/ERC20.ts","../src/permits.ts","../src/helpers.ts","../src/types.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import type {\n  BaseContract,\n  BigNumber,\n  BigNumberish,\n  BytesLike,\n  CallOverrides,\n  ContractTransaction,\n  Overrides,\n  PopulatedTransaction,\n  Signer,\n  utils,\n} from \"ethers\";\nimport type {\n  FunctionFragment,\n  Result,\n  EventFragment,\n} from \"@ethersproject/abi\";\nimport type { Listener, Provider } from \"@ethersproject/providers\";\nimport type {\n  TypedEventFilter,\n  TypedEvent,\n  TypedListener,\n  OnEvent,\n} from \"@eulerxyz/euler-interfaces/types/common\";\n\n\nexport const abi = [\n  \"event Approval(address indexed owner, address indexed spender, uint value)\",\n  \"event Transfer(address indexed from, address indexed to, uint value)\",\n  \"function name() external view returns (string memory)\",\n  \"function symbol() external view returns (string memory)\",\n  \"function decimals() external view returns (uint8)\",\n  \"function totalSupply() external view returns (uint)\",\n  \"function balanceOf(address owner) external view returns (uint)\",\n  \"function allowance(address owner, address spender) external view returns (uint)\",\n  \"function approve(address spender, uint value) external returns (bool)\",\n  \"function transfer(address to, uint value) external returns (bool)\",\n  \"function transferFrom(address from, address to, uint value) external returns (bool)\",\n];\n\n\nexport interface ERC20Interface extends utils.Interface {\n  functions: {\n    \"allowance(address,address)\": FunctionFragment;\n    \"approve(address,uint256)\": FunctionFragment;\n    \"balanceOf(address)\": FunctionFragment;\n    \"decimals()\": FunctionFragment;\n    \"name()\": FunctionFragment;\n    \"symbol()\": FunctionFragment;\n    \"totalSupply()\": FunctionFragment;\n    \"transfer(address,uint256)\": FunctionFragment;\n    \"transferFrom(address,address,uint256)\": FunctionFragment;\n  };\n\n  getFunction(\n    nameOrSignatureOrTopic:\n      | \"allowance\"\n      | \"approve\"\n      | \"balanceOf\"\n      | \"decimals\"\n      | \"name\"\n      | \"symbol\"\n      | \"totalSupply\"\n      | \"transfer\"\n      | \"transferFrom\"\n  ): FunctionFragment;\n\n  encodeFunctionData(\n    functionFragment: \"allowance\",\n    values: [string, string]\n  ): string;\n  encodeFunctionData(\n    functionFragment: \"approve\",\n    values: [string, BigNumberish]\n  ): string;\n  encodeFunctionData(functionFragment: \"balanceOf\", values: [string]): string;\n  encodeFunctionData(functionFragment: \"decimals\", values?: undefined): string;\n  encodeFunctionData(functionFragment: \"name\", values?: undefined): string;\n  encodeFunctionData(functionFragment: \"symbol\", values?: undefined): string;\n  encodeFunctionData(\n    functionFragment: \"totalSupply\",\n    values?: undefined\n  ): string;\n  encodeFunctionData(\n    functionFragment: \"transfer\",\n    values: [string, BigNumberish]\n  ): string;\n  encodeFunctionData(\n    functionFragment: \"transferFrom\",\n    values: [string, string, BigNumberish]\n  ): string;\n\n  decodeFunctionResult(functionFragment: \"allowance\", data: BytesLike): Result;\n  decodeFunctionResult(functionFragment: \"approve\", data: BytesLike): Result;\n  decodeFunctionResult(functionFragment: \"balanceOf\", data: BytesLike): Result;\n  decodeFunctionResult(functionFragment: \"decimals\", data: BytesLike): Result;\n  decodeFunctionResult(functionFragment: \"name\", data: BytesLike): Result;\n  decodeFunctionResult(functionFragment: \"symbol\", data: BytesLike): Result;\n  decodeFunctionResult(\n    functionFragment: \"totalSupply\",\n    data: BytesLike\n  ): Result;\n  decodeFunctionResult(functionFragment: \"transfer\", data: BytesLike): Result;\n  decodeFunctionResult(\n    functionFragment: \"transferFrom\",\n    data: BytesLike\n  ): Result;\n\n  events: {\n    \"Approval(address,address,uint256)\": EventFragment;\n    \"Transfer(address,address,uint256)\": EventFragment;\n  };\n\n  getEvent(nameOrSignatureOrTopic: \"Approval\"): EventFragment;\n  getEvent(nameOrSignatureOrTopic: \"Transfer\"): EventFragment;\n}\n\nexport interface ApprovalEventObject {\n  owner: string;\n  spender: string;\n  value: BigNumber;\n}\nexport type ApprovalEvent = TypedEvent<\n  [string, string, BigNumber],\n  ApprovalEventObject\n>;\n\nexport type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;\n\nexport interface TransferEventObject {\n  from: string;\n  to: string;\n  value: BigNumber;\n}\nexport type TransferEvent = TypedEvent<\n  [string, string, BigNumber],\n  TransferEventObject\n>;\n\nexport type TransferEventFilter = TypedEventFilter<TransferEvent>;\n\nexport interface ERC20Contract extends BaseContract {\n  connect(signerOrProvider: Signer | Provider | string): this;\n  attach(addressOrName: string): this;\n  deployed(): Promise<this>;\n\n  interface: ERC20Interface;\n\n  queryFilter<TEvent extends TypedEvent>(\n    event: TypedEventFilter<TEvent>,\n    fromBlockOrBlockhash?: string | number | undefined,\n    toBlock?: string | number | undefined\n  ): Promise<Array<TEvent>>;\n\n  listeners<TEvent extends TypedEvent>(\n    eventFilter?: TypedEventFilter<TEvent>\n  ): Array<TypedListener<TEvent>>;\n  listeners(eventName?: string): Array<Listener>;\n  removeAllListeners<TEvent extends TypedEvent>(\n    eventFilter: TypedEventFilter<TEvent>\n  ): this;\n  removeAllListeners(eventName?: string): this;\n  off: OnEvent<this>;\n  on: OnEvent<this>;\n  once: OnEvent<this>;\n  removeListener: OnEvent<this>;\n\n  functions: {\n    allowance(\n      holder: string,\n      spender: string,\n      overrides?: CallOverrides\n    ): Promise<[BigNumber]>;\n\n    approve(\n      spender: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<ContractTransaction>;\n\n    balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;\n\n    decimals(overrides?: CallOverrides): Promise<[number]>;\n\n    name(overrides?: CallOverrides): Promise<[string]>;\n\n    symbol(overrides?: CallOverrides): Promise<[string]>;\n\n    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;\n\n    transfer(\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<ContractTransaction>;\n\n    transferFrom(\n      from: string,\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<ContractTransaction>;\n  };\n\n  allowance(\n    holder: string,\n    spender: string,\n    overrides?: CallOverrides\n  ): Promise<BigNumber>;\n\n  approve(\n    spender: string,\n    amount: BigNumberish,\n    overrides?: Overrides & { from?: string | Promise<string> }\n  ): Promise<ContractTransaction>;\n\n  balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;\n\n  decimals(overrides?: CallOverrides): Promise<number>;\n\n  name(overrides?: CallOverrides): Promise<string>;\n\n  symbol(overrides?: CallOverrides): Promise<string>;\n\n  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;\n\n  transfer(\n    to: string,\n    amount: BigNumberish,\n    overrides?: Overrides & { from?: string | Promise<string> }\n  ): Promise<ContractTransaction>;\n\n  transferFrom(\n    from: string,\n    to: string,\n    amount: BigNumberish,\n    overrides?: Overrides & { from?: string | Promise<string> }\n  ): Promise<ContractTransaction>;\n\n  callStatic: {\n    allowance(\n      holder: string,\n      spender: string,\n      overrides?: CallOverrides\n    ): Promise<BigNumber>;\n\n    approve(\n      spender: string,\n      amount: BigNumberish,\n      overrides?: CallOverrides\n    ): Promise<boolean>;\n\n    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;\n\n    decimals(overrides?: CallOverrides): Promise<number>;\n\n    name(overrides?: CallOverrides): Promise<string>;\n\n    symbol(overrides?: CallOverrides): Promise<string>;\n\n    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;\n\n    transfer(\n      to: string,\n      amount: BigNumberish,\n      overrides?: CallOverrides\n    ): Promise<boolean>;\n\n    transferFrom(\n      from: string,\n      to: string,\n      amount: BigNumberish,\n      overrides?: CallOverrides\n    ): Promise<boolean>;\n  };\n\n  filters: {\n    \"Approval(address,address,uint256)\"(\n      owner?: string | null,\n      spender?: string | null,\n      value?: null\n    ): ApprovalEventFilter;\n    Approval(\n      owner?: string | null,\n      spender?: string | null,\n      value?: null\n    ): ApprovalEventFilter;\n\n    \"Transfer(address,address,uint256)\"(\n      from?: string | null,\n      to?: string | null,\n      value?: null\n    ): TransferEventFilter;\n    Transfer(\n      from?: string | null,\n      to?: string | null,\n      value?: null\n    ): TransferEventFilter;\n  };\n\n  estimateGas: {\n    allowance(\n      holder: string,\n      spender: string,\n      overrides?: CallOverrides\n    ): Promise<BigNumber>;\n\n    approve(\n      spender: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<BigNumber>;\n\n    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;\n\n    decimals(overrides?: CallOverrides): Promise<BigNumber>;\n\n    name(overrides?: CallOverrides): Promise<BigNumber>;\n\n    symbol(overrides?: CallOverrides): Promise<BigNumber>;\n\n    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;\n\n    transfer(\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<BigNumber>;\n\n    transferFrom(\n      from: string,\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<BigNumber>;\n  };\n\n  populateTransaction: {\n    allowance(\n      holder: string,\n      spender: string,\n      overrides?: CallOverrides\n    ): Promise<PopulatedTransaction>;\n\n    approve(\n      spender: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<PopulatedTransaction>;\n\n    balanceOf(\n      account: string,\n      overrides?: CallOverrides\n    ): Promise<PopulatedTransaction>;\n\n    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;\n\n    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;\n\n    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;\n\n    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;\n\n    transfer(\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<PopulatedTransaction>;\n\n    transferFrom(\n      from: string,\n      to: string,\n      amount: BigNumberish,\n      overrides?: Overrides & { from?: string | Promise<string> }\n    ): Promise<PopulatedTransaction>;\n  };\n}\n","import { BigNumberish, ethers } from \"ethers\";\n\nconst ABI_EIP2612 = [\n  \"function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)\",\n  \"function nonces(address owner) view returns (uint)\",\n  \"function _nonces(address owner) view returns (uint)\",\n];\nconst ABI_EIP2612_PACKED = [\n  \"function permit(address owner, address spender, uint value, uint deadline, bytes signature)\",\n  \"function nonces(address owner) view returns (uint)\",\n];\nconst ABI_ALLOWED = [\n  \"function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\",\n  \"function nonces(address owner) view returns (uint)\",\n];\n\nconst TYPES_PERMIT_EIP2612 = {\n  Permit: [\n    {\n      name: \"owner\",\n      type: \"address\",\n    },\n    {\n      name: \"spender\",\n      type: \"address\",\n    },\n    {\n      name: \"value\",\n      type: \"uint256\",\n    },\n    {\n      name: \"nonce\",\n      type: \"uint256\",\n    },\n    {\n      name: \"deadline\",\n      type: \"uint256\",\n    },\n  ],\n};\nconst TYPES_PERMIT_ALLOWED = {\n  Permit: [\n    {\n      name: \"holder\",\n      type: \"address\",\n    },\n    {\n      name: \"spender\",\n      type: \"address\",\n    },\n    {\n      name: \"nonce\",\n      type: \"uint256\",\n    },\n    {\n      name: \"expiry\",\n      type: \"uint256\",\n    },\n    {\n      name: \"allowed\",\n      type: \"bool\",\n    },\n  ],\n};\n\nexport const signPermit = async (\n  tokenAddress: string,\n  { type, variant, domain }: { type: string; variant?: string; domain: any },\n  {\n    spender,\n    value,\n    allowed,\n    deadline,\n  }: {\n    spender: string;\n    value?: BigNumberish;\n    allowed?: boolean;\n    deadline: number;\n  },\n  signer: ethers.Signer\n) => {\n  if (!ethers.Signer.isSigner(signer)) {\n    throw new Error(\"Invalid signer\");\n  }\n\n  // future proof experimental feature\n  const sign = (signer as any)._signTypedData\n    ? (signer as any)._signTypedData.bind(signer)\n    : (signer as any).signTypedData.bind(signer);\n\n  const signerAddress = await signer.getAddress();\n\n  if (type === \"EIP2612\") {\n    const token = new ethers.Contract(\n      tokenAddress,\n      variant === \"PACKED\" ? ABI_EIP2612_PACKED : ABI_EIP2612,\n      signer\n    );\n\n    let nonce;\n\n    if (variant === \"UNDERSCORE_NONCES\") {\n      nonce = await token._nonces(signerAddress);\n    } else {\n      nonce = await token.nonces(signerAddress);\n    }\n\n    const rawSignature = await sign(domain, TYPES_PERMIT_EIP2612, {\n      owner: signerAddress,\n      spender,\n      value,\n      nonce,\n      deadline,\n    });\n\n    return {\n      signature: {\n        raw: rawSignature,\n        ...ethers.utils.splitSignature(rawSignature),\n      },\n      nonce,\n    };\n  }\n\n  if (type === \"ALLOWED\") {\n    const token = new ethers.Contract(tokenAddress, ABI_ALLOWED, signer);\n    const nonce = await token.nonces(signerAddress);\n\n    const rawSignature = await sign(domain, TYPES_PERMIT_ALLOWED, {\n      holder: signerAddress,\n      spender,\n      nonce,\n      expiry: deadline,\n      allowed,\n    });\n\n    return {\n      signature: {\n        raw: rawSignature,\n        ...ethers.utils.splitSignature(rawSignature),\n      },\n      nonce,\n    };\n  }\n\n  throw new Error(`Unknown permit type: ${type}`);\n};\n","import { ethers, utils } from \"ethers\";\nimport invariant from \"tiny-invariant\";\n\nexport const uncapitalize = (str: string) =>\n  str.charAt(0).toLowerCase() + str.substring(1);\n\nexport const validateAddress = (address: string) => {\n  invariant(ethers.utils.isAddress(address), \"Invalid address\");\n};\n\nexport const secondsFromNow = (seconds: number) =>\n  Math.floor((Date.now() + seconds * 1000) / 1000);\n\nexport const parseError = (e: any) => {\n  // contracts don't decode certain external revert reasons correctly (Utils.sol)\n  if (e.reason === \"invalid codepoint at offset 2; missing continuation byte\") {\n    try {\n      let msg = utils.defaultAbiCoder.decode([\"string\"], e.value.slice(4))[0];\n      e.reason = msg;\n      msg = `execution reverted: ${msg}`\n      e.message = msg;\n      e.msg = msg;\n      e.code = msg;\n    } catch {}\n  }\n\n  return e;\n}\n","import { Contract, providers, Signer, BytesLike, ContractInterface } from \"ethers\";\nimport * as contracts from \"./eulerTypes\";\nimport { ERC20Contract } from \"./ERC20\";\n\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type BatchItem = {\n  contract: string | Contract;\n  address?: string;\n  method: string;\n  args: any[];\n  allowError?: boolean;\n  staticCall?: boolean;\n};\n\nexport type BatchResponse = {\n  success: boolean;\n  result: BytesLike;\n};\n\nexport type Token = {\n  name: string;\n  address: string;\n  chainId: number;\n  symbol: string;\n  decimals: number;\n  image?: string;\n  extensions?: any;\n};\n\nexport type TokenWithPermit = Token & {\n  extensions: {\n    permit: {\n      type: string;\n      variant?: string;\n      domain: RequireAtLeastOne<\n        {\n          name?: string;\n          version?: string;\n          chainId?: number;\n          verifyingContract?: string;\n          salt?: string;\n        },\n        \"name\" | \"version\" | \"chainId\" | \"verifyingContract\" | \"salt\"\n      >;\n    };\n    [key: string]: any;\n  };\n};\n\nexport type EulerAddresses = {\n  euler: string;\n  exec: string;\n  liquidation: string;\n  markets: string;\n  swap: string;\n  eulStakes: string;\n  eulDistributor: string;\n  eulerGeneralView: string;\n  eul: string;\n  [contractName: string]: string;\n};\n\nexport type EulerABIs = {\n  euler: ContractInterface;\n  exec: ContractInterface;\n  liquidation: ContractInterface;\n  markets: ContractInterface;\n  swap: ContractInterface;\n  eulStakes: ContractInterface;\n  eulDistributor: ContractInterface;\n  eulerGeneralView: ContractInterface;\n  eul: ContractInterface;\n  eToken: ContractInterface;\n  dToken: ContractInterface;\n  pToken: ContractInterface;\n  [contractName: string]: ContractInterface;\n};\n\nexport type NetworkConfig = {\n  addresses: EulerAddresses;\n  referenceAsset: string;\n  eul: TokenWithPermit;\n};\n\nexport type SignerOrProvider = providers.Provider | Signer | string;\n\nexport type Contracts = {\n  euler: contracts.EulerContract;\n  exec: contracts.ExecContract;\n  liquidation: contracts.LiquidationContract;\n  markets: contracts.MarketsContract;\n  swap: contracts.SwapContract;\n  eulStakes: contracts.EulStakesContract;\n  eulDistributor: contracts.EulDistributorContract;\n  eulerGeneralView: contracts.EulerGeneralViewContract;\n  eul: contracts.EulContract;\n  [contractName: string]: Contract;\n};\n\n\n// export type TokenCache = {\n//   'erc20': {\n//     [address: string]: Contract | ERC20Contract\n//   },\n//   'eToken': {\n//     [address: string]: Contract | contracts.ETokenContract\n//   },\n//   'dToken': {\n//     [address: string]: Contract | contracts.DTokenContract\n//   },\n//   'pToken': {\n//     [address: string]: Contract | contracts.PTokenContract\n//   }\n// };\n\nexport enum TokenType {\n  ERC20 = \"erc20\",\n  EToken = \"eToken\",\n  DToken = \"dToken\",\n  PToken = \"pToken\"\n}\n\nexport type TokenCache = {\n  [type: string]: {\n    [address: string]: \n      Contract\n      | ERC20Contract\n      | contracts.ETokenContract\n      | contracts.DTokenContract\n      | contracts.PTokenContract\n  }\n};\n\nexport type UnderlyingToTokenCache = {\n  [underlying: string]: {\n    [type: string]: string\n  }\n};","import { BigNumber, utils } from \"ethers\";\n\nexport function getSubAccountId(primaryAddress: string, subAccountAddress: string) {\n  return BigNumber.from(primaryAddress).xor(subAccountAddress).toNumber();\n}\n\nexport function isRealSubAccount(primaryAddress: string, subAccountAddress: string) {\n  return BigNumber.from(primaryAddress).xor(subAccountAddress).lt(256);\n}\n\nexport function getSubAccount(primary: string, subAccountId: number | string) {\n  if (parseInt(subAccountId as string) !== subAccountId || subAccountId > 256)\n    throw `invalid subAccountId: ${subAccountId}`\n  return utils.hexZeroPad(\n    BigNumber.from(primary).xor(subAccountId).toHexString(),\n    20,\n  )\n}\n","import { ethers, ContractInterface, providers, Contract } from \"ethers\";\nimport invariant from \"tiny-invariant\";\nimport { abi as ERC20Abi, ERC20Contract } from \"./ERC20\";\nimport { signPermit } from \"./permits\";\nimport {\n  uncapitalize,\n  validateAddress,\n  secondsFromNow,\n  parseError,\n} from \"./helpers\";\n\nimport * as utils from \"./utils\";\n\nimport addressesMainnet from \"@eulerxyz/euler-interfaces/addresses/addresses-mainnet.json\";\nimport addressesRopsten from \"@eulerxyz/euler-interfaces/addresses/addresses-ropsten.json\";\nimport addressesGoerli from \"@eulerxyz/euler-interfaces/addresses/addresses-goerli.json\";\nimport * as eulerAbis from \"./eulerAbis\";\n\nimport {\n  BatchItem,\n  BatchResponse,\n  TokenWithPermit,\n  EulerAddresses,\n  NetworkConfig,\n  SignerOrProvider,\n  Contracts,\n  TokenCache,\n  TokenType,\n  UnderlyingToTokenCache,\n} from \"./types\";\nimport {\n  EulContract,\n  EulerContract,\n  PTokenContract,\n  ETokenContract,\n  DTokenContract,\n  ExecContract,\n  LiquidationContract,\n  MarketsContract,\n  SwapContract,\n  EulStakesContract,\n  EulDistributorContract,\n  EulerGeneralViewContract,\n} from \"./eulerTypes\";\n\nconst WETH_MAINNET = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\nconst WETH_ROPSTEN = \"0xc778417e063141139fce010982780140aa0cd5ab\";\nconst WETH_GOERLI = \"0xa3401DFdBd584E918f59fD1C3a558467E373DacC\";\n\nconst DEFAULT_PERMIT_DEADLINE_SECONDS = 60 * 60;\nconst LIQUIDITY_CHECK_ERRORS = [\n  \"e/collateral-violation\",\n  \"e/borrow-isolation-violation\",\n];\n\nclass Euler {\n  readonly chainId: number;\n  readonly contracts: Contracts;\n  readonly abis: { [contractName: string]: ContractInterface };\n  readonly addresses: EulerAddresses;\n  readonly eulTokenConfig: TokenWithPermit;\n  readonly referenceAsset: string;\n\n  private _tokenCache: TokenCache;\n  private _underlyingToTokenCache: UnderlyingToTokenCache;\n  private _signerOrProvider?: SignerOrProvider;\n\n  constructor(\n    signerOrProvider?: SignerOrProvider,\n    chainId = 1,\n    networkConfig?: NetworkConfig\n  ) {\n    this.chainId = chainId;\n    this._tokenCache = {\n      [TokenType.EToken]: {},\n      [TokenType.DToken]: {},\n      [TokenType.PToken]: {},\n      [TokenType.ERC20]: {},\n    };\n    this._underlyingToTokenCache = {};\n    this._signerOrProvider = signerOrProvider;\n\n    if (this.chainId === 1) {\n      const { eul: eulConfig, ...addresses } = addressesMainnet;\n      this.eulTokenConfig = eulConfig;\n      this.addresses = addresses as any;\n\n      this.referenceAsset = WETH_MAINNET;\n    } else if (this.chainId === 3) {\n      const { eul: eulConfig, ...addresses } = addressesRopsten;\n      this.eulTokenConfig = eulConfig;\n      this.addresses = addresses as any;\n\n      this.referenceAsset = WETH_ROPSTEN;\n    } else if (this.chainId === 420) {\n      const { eul: eulConfig, ...addresses } = addressesGoerli;\n      this.eulTokenConfig = eulConfig;\n      this.addresses = addresses as any;\n\n      this.referenceAsset = WETH_GOERLI;\n    } else if (networkConfig) {\n      invariant(\n        networkConfig.addresses,\n        `Missing addresses for chainId ${this.chainId}`\n      );\n      invariant(\n        networkConfig.referenceAsset,\n        `Missing reference asset for chainId ${this.chainId}`\n      );\n\n      this.addresses = networkConfig.addresses;\n      this.referenceAsset = networkConfig.referenceAsset;\n      this.eulTokenConfig = networkConfig.eul;\n    } else {\n      throw new Error(\"Unknown configuration\");\n    }\n\n    this.abis = eulerAbis;\n    this.contracts = this._loadEulerContracts();\n  }\n\n  connect(signerOrProvider: SignerOrProvider) {\n    this._signerOrProvider = signerOrProvider;\n    Object.entries(this.contracts).forEach(([key, c]) => {\n      this.contracts[key] = c.connect(signerOrProvider);\n    });\n\n    return this;\n  }\n\n  getSigner() {\n    if (ethers.Signer.isSigner(this._signerOrProvider)) {\n      return this._signerOrProvider;\n    } else if (\n      ethers.providers.BaseProvider.isProvider(this._signerOrProvider)\n    ) {\n      try {\n        return (\n          this._signerOrProvider as providers.JsonRpcProvider\n        ).getSigner();\n      } catch {}\n    }\n    return null;\n  }\n\n  getProvider() {\n    if (ethers.providers.BaseProvider.isProvider(this._signerOrProvider)) {\n      return this._signerOrProvider;\n    } else if (\n      ethers.Signer.isSigner(this._signerOrProvider) &&\n      this._signerOrProvider.provider\n    ) {\n      return this._signerOrProvider.provider;\n    }\n    return null;\n  }\n\n  addContract(name: string, abi?: ContractInterface, address?: string) {\n    invariant(name, \"Contract name is required\");\n\n    name = uncapitalize(name);\n\n    abi = abi || this.abis[name];\n    invariant(Array.isArray(abi), \"Missing or invalid abi\");\n\n    address = address || (this.addresses[name] as string);\n    validateAddress(address);\n\n    this.contracts[name] = new ethers.Contract(\n      address,\n      abi,\n      typeof this._signerOrProvider === \"string\"\n        ? undefined\n        : this._signerOrProvider\n    );\n    this.abis[name] = abi;\n    this.addresses[name] = address;\n  }\n\n  erc20(address: string) {\n    validateAddress(address);\n    return this._getToken(address, TokenType.ERC20) as ERC20Contract;\n  }\n\n  eToken(address: string) {\n    validateAddress(address);\n    return this._getToken(address, TokenType.EToken) as ETokenContract;\n  }\n\n  dToken(address: string) {\n    validateAddress(address);\n    return this._getToken(address, TokenType.DToken) as DTokenContract;\n  }\n\n  pToken(address: string) {\n    validateAddress(address);\n    return this._getToken(address, TokenType.PToken) as PTokenContract;\n  }\n\n  eTokenOf(underlyingAddress: string) {\n    validateAddress(underlyingAddress);\n    return this._getTokenOf(\n      underlyingAddress,\n      TokenType.EToken\n    ) as Promise<ETokenContract>;\n  }\n\n  dTokenOf(underlyingAddress: string) {\n    validateAddress(underlyingAddress);\n    return this._getTokenOf(\n      underlyingAddress,\n      TokenType.DToken\n    ) as Promise<DTokenContract>;\n  }\n\n  pTokenOf(underlyingAddress: string) {\n    validateAddress(underlyingAddress);\n    return this._getTokenOf(\n      underlyingAddress,\n      TokenType.PToken\n    ) as Promise<PTokenContract>;\n  }\n\n  buildBatch(items: BatchItem[]) {\n    return items.map((currItem) => {\n      let item = { ...currItem };\n      if (item.staticCall) {\n        const scContract = this._batchItemToContract(item);\n        const scPayload = scContract.interface.encodeFunctionData(\n          item.method as any,\n          item.args as any\n        );\n\n        item = {\n          allowError: item.allowError,\n          contract: \"exec\",\n          method: \"doStaticCall\",\n          args: [scContract.address, scPayload],\n        };\n      }\n\n      const contract = this._batchItemToContract(item);\n\n      return {\n        allowError: Boolean(item.allowError),\n        proxyAddr: contract.address,\n        data: contract.interface.encodeFunctionData(\n          item.method as any,\n          item.args as any\n        ),\n      };\n    });\n  }\n\n  async simulateBatch(deferredLiquidity: string[], items: BatchItem[]) {\n    invariant(Array.isArray(items), \"Expecting an array of batch items\");\n\n    const simulate = async () => {\n      try {\n        await this.contracts.exec.callStatic.batchDispatchSimulate(\n          this.buildBatch(items),\n          deferredLiquidity\n        );\n      } catch (e) {\n        if (e.errorName !== \"BatchDispatchSimulation\") throw e;\n        return this.decodeBatch(items, e.errorArgs.simulation);\n      }\n    };\n\n    const estimateGas = async () => {\n      const nonStaticItems = items.filter((i) => !i.staticCall);\n      try {\n        const gas = await this.contracts.exec.estimateGas.batchDispatch(\n          this.buildBatch(nonStaticItems || items),\n          deferredLiquidity\n        );\n        return { gas };\n      } catch (e) {\n        if (e.reason) {\n          for (const liquidityCheckError of LIQUIDITY_CHECK_ERRORS) {\n            if (e.reason.includes(liquidityCheckError))\n              return {\n                error: {\n                  isLiquidityCheck: true,\n                  value: e,\n                },\n              };\n          }\n        }\n        return {\n          error: {\n            isLiquidityCheck: false,\n            value: e,\n          },\n        };\n      }\n    };\n\n    const [simulation, { gas, error }] = await Promise.all([\n      simulate(),\n      estimateGas(),\n    ]);\n\n    return {\n      simulation,\n      gas,\n      error,\n    };\n  }\n\n  decodeBatch(items: BatchItem[], resp: BatchResponse[]) {\n    const decoded: any[] = [];\n\n    for (let i = 0; i < resp.length; i++) {\n      const item = items[i];\n      let decodedItem;\n      try {\n        const decoded = this._batchItemToContract(\n          item\n        ).interface.decodeFunctionResult(item.method as any, resp[i].result);\n        decodedItem = {\n          success: true,\n          response: decoded,\n        };\n      } catch (e) {\n        decodedItem = {\n          success: false,\n          response: parseError(e),\n        };\n      }\n\n      decoded.push(decodedItem);\n    }\n\n    return decoded;\n  }\n\n  signPermit(\n    token: TokenWithPermit,\n    {\n      spender = this.contracts.euler.address,\n      value = ethers.constants.MaxUint256,\n      allowed = true,\n      deadline = secondsFromNow(DEFAULT_PERMIT_DEADLINE_SECONDS),\n    },\n    signer = this.getSigner()\n  ) {\n    invariant(\n      ethers.Signer.isSigner(this._signerOrProvider),\n      \"Signer in not provided\"\n    );\n    invariant(\n      token && token.extensions && token.extensions.permit,\n      \"Invalid token or missing permit config\"\n    );\n\n    const { type, variant, domain } = token.extensions.permit;\n\n    return signPermit(\n      token.address,\n      { type, variant, domain },\n      { spender, value, allowed, deadline },\n      signer as ethers.Signer\n    );\n  }\n\n  async signPermitBatchItem(\n    token: TokenWithPermit,\n    {\n      value = ethers.constants.MaxUint256,\n      allowed = true,\n      deadline = secondsFromNow(DEFAULT_PERMIT_DEADLINE_SECONDS),\n    },\n    allowError = false,\n    signer = this.getSigner()\n  ) {\n    const { nonce, signature } = await this.signPermit(\n      token,\n      { spender: this.contracts.euler.address, value, allowed, deadline },\n      signer\n    );\n\n    const { type, variant } = token.extensions.permit;\n    let batchItem;\n\n    if (type === \"EIP2612\") {\n      if (variant === \"PACKED\") {\n        batchItem = {\n          allowError,\n          contract: \"exec\",\n          method: \"usePermitPacked\",\n          args: [token.address, value, deadline, signature.raw],\n        };\n      } else {\n        batchItem = {\n          allowError,\n          contract: \"exec\",\n          method: \"usePermit\",\n          args: [\n            token.address,\n            value,\n            deadline,\n            signature.v,\n            signature.r,\n            signature.s,\n          ],\n        };\n      }\n    } else {\n      batchItem = {\n        allowError,\n        contract: \"exec\",\n        method: \"usePermitAllowed\",\n        args: [\n          token.address,\n          nonce,\n          deadline,\n          allowed,\n          signature.v,\n          signature.r,\n          signature.s,\n        ],\n      };\n    }\n    return batchItem;\n  }\n\n  private _getToken(address: string, type: TokenType) {\n    if (!this._tokenCache[type][address]) {\n      this._tokenCache[type][address] = new ethers.Contract(\n        address,\n        type === TokenType.ERC20 ? ERC20Abi : this.abis[type],\n        typeof this._signerOrProvider === \"string\"\n          ? undefined\n          : this._signerOrProvider\n      );\n    }\n\n    return this._signerOrProvider\n      ? this._tokenCache[type][address].connect(this._signerOrProvider)\n      : this._tokenCache[type][address];\n  }\n\n  private async _getTokenOf(underlyingAddress: string, type: TokenType) {\n    if (!this._underlyingToTokenCache[underlyingAddress]) {\n      this._underlyingToTokenCache[underlyingAddress] = {};\n    }\n\n    if (!this._underlyingToTokenCache[underlyingAddress][type]) {\n      let tokenAddress;\n      if (type === TokenType.EToken) {\n        tokenAddress = await this.contracts.markets.underlyingToEToken(\n          underlyingAddress\n        );\n      } else if (type === TokenType.DToken) {\n        tokenAddress = await this.contracts.markets.underlyingToDToken(\n          underlyingAddress\n        );\n      } else if (type === TokenType.PToken) {\n        tokenAddress = await this.contracts.markets.underlyingToPToken(\n          underlyingAddress\n        );\n      } else {\n        throw new Error(`Unsupported token type: ${type}`);\n      }\n      if (tokenAddress === ethers.constants.AddressZero)\n        throw new Error(`No ${type} found for underlying ${underlyingAddress}`);\n\n      this._underlyingToTokenCache[underlyingAddress][type] = tokenAddress;\n    }\n\n    return this[type](this._underlyingToTokenCache[underlyingAddress][type]);\n  }\n\n  private _batchItemToContract(item: BatchItem) {\n    if (item.contract instanceof ethers.Contract) return item.contract;\n    if (this.contracts[item.contract]) return this.contracts[item.contract];\n\n    if (item.address) {\n      if (item.contract === TokenType.EToken) return this.eToken(item.address);\n      if (item.contract === TokenType.DToken) return this.dToken(item.address);\n      if (item.contract === TokenType.PToken) return this.pToken(item.address);\n      if (item.contract === TokenType.ERC20) return this.erc20(item.address);\n    }\n\n    throw new Error(`Unknown contract ${item.contract}`);\n  }\n\n  private _loadEulerContracts(): Contracts {\n    const createContract = (name: string) =>\n      new Contract(\n        this.addresses[uncapitalize(name)],\n        this.abis[uncapitalize(name)],\n        typeof this._signerOrProvider === \"string\"\n          ? undefined\n          : this._signerOrProvider\n      );\n\n    return {\n      euler: createContract(\"Euler\") as EulerContract,\n      exec: createContract(\"Exec\") as ExecContract,\n      liquidation: createContract(\"Liquidation\") as LiquidationContract,\n      markets: createContract(\"Markets\") as MarketsContract,\n      swap: createContract(\"Swap\") as SwapContract,\n      eulStakes: createContract(\"EulStakes\") as EulStakesContract,\n      eulDistributor: createContract(\n        \"EulDistributor\"\n      ) as EulDistributorContract,\n      eulerGeneralView: createContract(\n        \"EulerGeneralView\"\n      ) as EulerGeneralViewContract,\n      eul: new Contract(\n        this.eulTokenConfig.address,\n        this.abis.eul,\n        typeof this._signerOrProvider === \"string\"\n          ? undefined\n          : this._signerOrProvider\n      ) as EulContract,\n    };\n  }\n}\n\nexport { Euler, utils };\n"],"names":["abi","ABI_EIP2612","ABI_EIP2612_PACKED","ABI_ALLOWED","TYPES_PERMIT_EIP2612","Permit","name","type","TYPES_PERMIT_ALLOWED","uncapitalize","str","charAt","toLowerCase","substring","validateAddress","address","invariant","ethers","utils","isAddress","secondsFromNow","seconds","Math","floor","Date","now","parseError","e","reason","msg","defaultAbiCoder","decode","value","slice","message","code","TokenType","getSubAccountId","primaryAddress","subAccountAddress","BigNumber","from","xor","toNumber","isRealSubAccount","lt","getSubAccount","primary","subAccountId","parseInt","hexZeroPad","toHexString","_excluded","_excluded2","_excluded3","LIQUIDITY_CHECK_ERRORS","Euler","constructor","signerOrProvider","chainId","networkConfig","this","contracts","abis","addresses","eulTokenConfig","referenceAsset","_tokenCache","_underlyingToTokenCache","_signerOrProvider","EToken","DToken","PToken","ERC20","eul","eulConfig","addressesMainnet","addressesRopsten","_objectWithoutPropertiesLoose","addressesGoerli","Error","eulerAbis","_loadEulerContracts","connect","Object","entries","forEach","key","c","getSigner","Signer","isSigner","providers","BaseProvider","isProvider","_unused","getProvider","provider","addContract","Array","isArray","Contract","undefined","erc20","_getToken","eToken","dToken","pToken","eTokenOf","underlyingAddress","_getTokenOf","dTokenOf","pTokenOf","buildBatch","items","map","currItem","item","_extends","staticCall","scContract","_batchItemToContract","scPayload","interface","encodeFunctionData","method","args","allowError","contract","Boolean","proxyAddr","data","async","deferredLiquidity","_this","simulation","gas","error","Promise","all","exec","callStatic","batchDispatchSimulate","errorName","decodeBatch","errorArgs","simulate","nonStaticItems","filter","i","estimateGas","batchDispatch","liquidityCheckError","includes","isLiquidityCheck","resp","decoded","length","decodedItem","success","response","decodeFunctionResult","result","push","signPermit","token","spender","euler","constants","MaxUint256","allowed","deadline","signer","extensions","permit","variant","domain","tokenAddress","sign","_signTypedData","bind","signTypedData","signerAddress","getAddress","nonce","_nonces","nonces","rawSignature","owner","signature","raw","splitSignature","holder","expiry","batchItem","v","r","s","ERC20Abi","markets","underlyingToEToken","underlyingToDToken","underlyingToPToken","AddressZero","createContract","liquidation","swap","eulStakes","eulDistributor","eulerGeneralView"],"mappings":"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"}